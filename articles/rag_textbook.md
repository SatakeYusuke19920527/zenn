---
title: 'RAG の教科書'
emoji: '📚'
type: 'tech' # tech: 技術記事 / idea: アイデア
topics: ['RAG', 'LLM', 'AI', 'Azure', 'GenAI']
published: false
publication_name: microsoft
---

# 目次

- [はじめに](#はじめに)
- [RAG の概要](#rag-の概要)
  - [RAG のアプローチ](#rag-のアプローチ)
  - [Agent 時代の RAG](#agent-時代の-rag)
- [RAG の精度改善の進め方](#rag-の精度改善の進め方)
  - [Store の精度向上 (データ準備)](#store-の精度向上-データ準備)
  - [Retrieve の精度向上 (検索)](#retrieve-の精度向上-検索)
  - [Augment の精度向上 (拡張)](#augment-の精度向上-拡張)
  - [Generation の精度向上 (生成)](#generation-の精度向上-生成)
- [Evaluate (評価)](#evaluate-評価)
- [RAG とファインチューニング](#rag-とファインチューニング)
- [RAG と CAG](#rag-と-cag)
- [その他](#その他)
- [参考文献](#参考文献)

# はじめに

昨今、AI の進化により、様々な分野での応用が進んでいます。特に、自然言語処理(NLP)の分野では、RAG( Retrieval-Augmented Generation)が注目されています。RAG は、情報検索と生成を組み合わせた手法であり、特に大規模言語モデル(LLM)と組み合わせることで、その性能を大幅に向上させることができます。

また、NativeRAG や GraphRAG, AgentRAG などさまざまな RAG のバリエーションが登場しており、これらは特定のユースケースやデータセットに対して最適化されています。

今回は、RAG の基本的な概念から、RAG のプロジェクトの進め方、精度向上の方法に至るまで詳しく解説します。

みなさんの GenAI Application の開発に役立てていただければ幸いです。

それでは行きましょう 🚀

# RAG の概要

RAG とは`Retrieval-Augmented Generation`の略で、情報検索と生成を組み合わせた手法です。
RAG は特に大規模言語モデル(LLM)と組み合わせることで、その性能を大幅に向上させることができます。

歴史的には**Meta の研究者が提案**した、LLM のハルシネーション（誤情報生成）を低減する手法で、LLM だけの思考ではなく、外部リソースに検索をかけながら正しい答えを生成する言わば **「ナレッジベースの外部化」** が実現出来る手法です。

ユーザーからの問いに対し、バックエンドのナレッジベース（例: Azure AI Search）で検索し、その結果をプロンプトに追加して回答を生成するような流れが一般的な流れになります。

RAG の概要のフローは以下のようになっています。

![](https://storage.googleapis.com/zenn-user-upload/885069742116-20250524.png)

1. Store で各種データをチャンク分割し、ベクトル化してデータストア(Azure AI Search 等)に格納します。
2. ユーザーからの質問を Application 側で受け取ります。
3. Retrieve と記載されている場所で、キーワード検索やベクトル検索を実施します。
4. 関連する情報をデータストアから取得します。
5. ユーザーからの質問とデータストアから取得した関連情報を、Augment の箇所でビルドします。
6. 生成 AI の API(Azure OpenAI Service 等)に、ユーザーからの質問とデータストアから取得した関連情報をプロンプトとして渡します。
7. 質問と関連情報を元に回答を生成します。
8. 生成された回答をユーザーに返します。

このように RAG は以下 4 つの箇所に分割することが出来ます。

- **Store** : データの格納
- **Retrieve** : データの検索
- **Augment** : プロンプトのビルド
- **Generation** : 回答の生成

## RAG のアプローチ

RAG の精度をあげるための手法の研究は進んでおり、キーワード/ベクトル検索に基づく **NativeRAG**、KG（ナレッジグラフ）を活用する **GraphRAG**、そして両者を組み合わせる **HybridRAG** が主要な選択肢として挙げられます。

また、昨今注目されているのは**AgenticRAG**と呼ばれる手法で、従来の RAG が抱える「静的なワークフロー」「単一ステップ推論」等の限界を乗り越えるべく、LLM をエージェント化（計画・再試行・ツール活用・他エージェントとの協調など）。クエリごとに動的に検索戦略を変えたり、回答途中に不足情報を再検索したり、複数のエージェント間でタスクを分担して協調する。

RAG の比較をまとめてみました。

| アプローチ        | ユースケース                                                                                                                                                                                                                                   | 検索手法                                                                                                                                                                                                                             | 強み                                                                                                                                                                                                                 | 弱み                                                                                                                                                                                                               |
| ----------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 🧠 **NativeRAG**  | ・幅広いドキュメント検索<br>・FAQ やカスタマーサポート<br>・表現のゆらぎへの対応                                                                                                                                                               | ・キーワード検索<br>・ベクトル検索<br>・セマンティックリランキング                                                                                                                                                                   | ・スキーマ不要で実装が容易<br>・大規模非構造テキストを取り込みやすい<br>・柔軟性が高い                                                                                                                               | ・関係性の厳密な推論には弱い<br>・ノイズが多い場合、回答の正確性が下がる                                                                                                                                           |
| 📈 **GraphRAG**   | ・エンティティの厳密な関係性の追跡<br>・因果関係の分析<br>・説明責任が求められる場面                                                                                                                                                           | ・ナレッジグラフを用いた構造的な検索<br>・エンティティ・リレーションに基づく問い合わせ                                                                                                                                               | ・一貫性・説明可能性が高い<br>・ドメイン知識の活用に強み                                                                                                                                                             | ・ナレッジグラフ構築コストが高い<br>・エンティティが直接登場しない抽象質問に弱い                                                                                                                                   |
| 🔗 **HybridRAG**  | ・抽象的な質問にも対応しつつ関係性も正確に捉えたいケース<br>・非構造化データと構造化データが混在する複雑ドメイン                                                                                                                               | ・NativeRAG と GraphRAG の両方を実施<br>・ベクトル検索の文脈 & ナレッジグラフのサブグラフ情報を併用                                                                                                                                  | ・NativeRAG と GraphRAG の長所を活かし精度と柔軟性を両立<br>・抽象的質問 & エンティティ重視の質問両方に強い                                                                                                          | ・両方の結果をマージする分コンテキストが増大しがち<br>・実装・運用が複雑化しやすい                                                                                                                                 |
| 🤖 **AgenticRAG** | ・マルチソース横断のリアルタイム Q&A／データ統合チャットボット<br>・ステップ分解が必要な複雑タスク（法務調査・コーディング支援等）<br>・カスタマーサポート一次対応自動化とエスカレーション判定<br>・部門横断のナレッジ発見・データマネジメント | ・ルーティング／プランニングエージェントでツール選択（ベクトル検索・キーワード検索・Web 検索・API 呼び出し等）<br>・ReAct／Plan-and-Execute などのマルチステップ推論ループ<br>・専用リトリーバーを複数連携するマルチエージェント構成 | ・柔軟性・適応性が高く、動的にデータソース／ツールを切替可能<br>・自己検証ループでノイズを低減し精度向上<br>・マルチエージェント拡張で異種データ・マルチモーダル対応が容易<br>・単一ベクトル DB 依存より網羅性が高い | ・複数エージェントによる追加推論でコスト・レイテンシ増大<br>・エージェント行き詰まり／ハルシネーション対策が必須<br>・オーケストレーションや権限制御など実装・運用が複雑<br>・協調失敗時に処理が非効率になるリスク |

## Agent 時代の RAG

特に最近注目されている AgenticRAG について深掘りしていきたいと思います。

以下に AgenticRAG の調査もまとめられています。
https://arxiv.org/abs/2501.09136

> エージェント検索拡張生成 (AgenticRAG) は、自律型 AI エージェントを RAG パイプラインに組み込み、エージェント設計パターンの反映、計画、ツールの使用、およびマルチエージェント コラボレーションを活用して、検索戦略を動的に管理し、コンテキスト理解を反復的に改善し、複雑なタスク要件を満たすようにワークフローを適応させます。
> この統合により、AgenticRAG システムは、多様なアプリケーションにおいて比類のない柔軟性、拡張性、そしてコンテキスト認識を実現します。

AI Agent の要素は以下のものが挙げられます。

```mermaid
flowchart TB
    %% 中央コア
    C["AIエージェント<br>の要素"]

    %% 周辺ノード
    COORD(["マルチエージェント協調<br>複数のエージェントが協力してタスクを解決する。"])
    LLM(["LLM<br>エージェントの推論とテキスト生成の中核コンポーネント。"])
    MEMORY(["メモリ<br>知識と情報を保存するための短期および長期メモリ。"])
    PLAN(["計画<br>タスクを整理し、実行順序を決定するプロセス。"])
    TOOLS(["ツール活用<br>外部ツールを使用して LLM の能力を強化する。"])

    %% 配置（円形になるよう角度を指定）
    C ---| | COORD
    C ---| | LLM
    C ---| | MEMORY
    C ---| | PLAN
    C ---| | TOOLS

    %% レイアウト調整
    classDef default text-align:center
    class C default
    class COORD,LLM,MEMORY,PLAN,TOOLS default

    %% （任意）色付け例
    style COORD fill:#d9d5fa,stroke:#7370e4,stroke-width:1px
    style LLM fill:#bceaf7,stroke:#3ca0b7,stroke-width:1px
    style MEMORY fill:#c4f2e0,stroke:#28a07d,stroke-width:1px
    style PLAN fill:#e4f7c4,stroke:#a0c428,stroke-width:1px
    style TOOLS fill:#ffe5c4,stroke:#e8a74e,stroke-width:1px

```

マルチエージェントで強調することや、LLM、メモリ、計画、ツール活用などの要素を組み合わせて、より高度なタスク解決を目指します。

実際に、AgenticRAG の処理プロセスの例は以下のようになります。

```mermaid
flowchart TD
  A((クエリ送信))
  B(クエリ分析・検索戦略決定)
  C(外部ソース検索<br/>DB・ベクタ検索・Web等)
  D(Tools 検索結果返却)
  E(初期回答生成)
  F(回答の妥当性・根拠を評価)
  G{不十分?}
  H(再検索→追加情報取得)
  I(改善回答生成)
  J(最終回答をUserへ返却)
  K(回答受領)

  %% フロー
  A --> B --> C
  C --> D
  C --> E --> F --> G
  G -- はい --> H --> I --> F
  G -- いいえ --> J --> K
```

クエリ送信後、クエリの分析・検索戦略の決定を行い、外部ソース（データベース、ベクトル検索、Web など）から情報を取得します。その後、初期回答を生成し、その妥当性や根拠を評価します。
もし回答が不十分であれば、再度検索を行い追加情報を取得し、改善された回答を生成します。最終的に、ユーザーに最終回答を返却します。

今までの RAG では、Retrieve の結果をそのままプロンプトに追加して回答を生成していましたが、AgenticRAG では、クエリの分析や検索戦略の決定、回答の妥当性評価などのステップが追加され、より動的で柔軟な対応が可能になります。

:::message

Agentic RAG Core Loop と呼ばれますが、以下のトレーニングが非常に参考になります。
https://github.com/microsoft/ai-agents-for-beginners/blob/main/05-agentic-rag/README.md

:::

そして、一口に AgenticRAG と言っても、様々なアプローチが存在します。
今回は以下の 6 つのアプローチを紹介・比較します。

- シングルエージェント RAG
- マルチエージェント RAG
- 階層型エージェント RAG
- Corrective RAG
- Adaptive RAG
- Graph ベース RAG
- Agentic Document Workflows (ADW)

| 分類                                 | 概要                                                                                                         | 利点                                                                                                       | 注意点・課題                                                                                   | 主な用途・事例                                                                 |
| ------------------------------------ | ------------------------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------ |
| **シングルエージェント RAG**         | RAG の一連のタスクを、単一のエージェントがまとめて管理                                                       | すべて 1 エージェントで完結するため、エージェント間の連携不要                                              | ・高度な並列処理・専門化には限界<br>・大規模・複雑な処理には不向き                             | カスタマーサポートなど比較的単純な問い合わせ対応                               |
| **マルチエージェント RAG**           | コーディネーター役のエージェントがクエリを受け取り、複数の専門エージェントにサブタスクを振り分け、結果を統合 | 機能を専門化できるため、高度・複雑なタスクに対応しやすい。並列処理で高速化が可能                           | エージェント間連携の設計が複雑化                                                               | 大規模システムでの高度な情報検索・集約                                         |
| **階層型エージェント RAG**           | 上位エージェントが戦略レベルの判断を行い、下位エージェントが実務的な検索や解析を担う                         | 大規模・複雑な意思決定を効果的に管理                                                                       | 階層設計が不十分だとボトルネックを起こしやすい                                                 | 分析チーム・検索チームなど、複数部門をまたぐワークフロー制御                   |
| **CorrectiveRAG**                    | 検索結果が不正確・不足がある場合に自動で修正検索やクエリ再生成を行う仕組み                                   | ハルシネーションや検索ミスを低減                                                                           | エージェントの評価・修正プロセスを設計する必要。再検索や情報取得の手数が増え、処理コストが増大 | FAQ システムの回答精度向上、ファクトベースのレポーティングやカスタマーサポート |
| **AdaptiveRAG**                      | クエリの難易度（簡易・中程度・複雑など）に応じて検索・推論の手順を切り替える                                 | 不要な大規模処理を行わずに済むため効率が良い。シンプルな問題は高速に処理し、複雑な問題には多段階処理を適用 | クエリ分類の精度がシステム全体の性能に影響。過小評価・過大評価による処理パスのミスマッチ       | ユーザーからの多様な質問に対し最適な処理を選択するチャットボット               |
| **Graph ベース RAG**                 | ナレッジグラフとテキスト検索を組み合わせ、結果をクリティックモジュールなどで評価しながら精緻化               | リレーショナルな知識構造を活かした多段階推論が可能                                                         | グラフ DB の構築や更新が必要                                                                   | 医療や学術分野など、複雑なエンティティ関係を扱うシステム                       |
| **Agentic Document Workflows (ADW)** | 文書処理（インボイス、契約書、レポートなど）に特化したワークフロー                                           | 複数ステップの文書処理を一元化できる                                                                       | 文書形式ごとの細かな設定やテンプレート設計                                                     | 契約書の審査、自動請求処理、保険金請求管理など                                 |

AI Agent の Application の開発においては、開発するプロダクトが達成したい目標や、解決したい課題に応じて、適切なアプローチを選択することが重要です。

それぞれの利点や課題を正確に抑えながら、Agent の設計を行うことで、より効果的な AI Agent の開発が可能になります。

# RAG の精度改善の進め方 全体観

ここからは NativeRAG をベースに RAG を構築する上でのプロジェクトの進め方について紹介します。

### RAG アプリ全体プロセス

大まかな進め方は以下になります。
**要件整理 → POC／改善 → 本番構築 → 継続的改善**

個人的に最も大事だと思うポイントは要件定義から PoC に入るスピードとクオリティです。
決して高いクオリティを求めるのではなく、とりあえずやってみる精神で作っていくことが重要と感じています。

| フェーズ       | 概要                                                                                                                                                         | 準備物                                                             | 想定期間           |
| -------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------ | ------------------ |
| **要件整理**   | RAG における要件整理。**例**・想定ユーザ／使用方法・データ整理、データの持ち方・開発スケジュール・コスト／評価基準（本番化への）など                         | ・ヒアリング／要件整理シート ※1                                    | **1〜2 週間**      |
| **POC／改善**  | 一定の RAG 手法を含むベースラインアプリを利用したクイック POC。・検証／評価（質問・回答のセットを事前に準備）・課題把握（×× サイクル）・本番構築への意思決定 | ・RAG サンプルアプリ ※1・評価機能 ※1・課題–ソリューションマップ ※1 | **1 か月〜2 か月** |
| **本番構築**   | 本番運用向けアーキテクチャ設計と構築。・リファレンスアーキテクチャ × 顧客環境ポリシーに基づく最終アーキテクチャ整理・構築／責任ある AI                       | ・リファレンスアーキテクチャ・構築パートナー選定                   | **2 か月〜3 か月** |
| **継続的改善** | 本番展開時に発生した課題／要望への対応。・新たなデータ、質問等の新規要望に対する継続的な改善・継続的な会話ログ分析                                           | ・LLMOps／精度モニタリング・課題–ソリューションマップ              | **継続**           |

継続的な改善を進め、3 度目のリリースぐらいでいい形のプロダクトになることが多いです。
前述しましたが、初めから完璧を求めるのではなく、まずはやってみることが重要です。

PoC としては以下機能ぐらいあれば効果測定には十分です。

■ サンプルアプリ主要機能

- 【フロント UI】
  - ファイルアップロード機能
  - 検索パラメータ変更
  - ハイブリッドセマンティック検索等の複数検索手法
  - システムロール変更機能
  - プロンプト表示機能(with 検索結果)
  - 検索パラメータ / GPT パラメータ
  - AI 回答内での参照ファイル表示
- 【バックエンド】
  - AI-OCR (表対応)
  - セマンティックチャンキング
  - チャンクエンリッチメント(タイトル、要約、キーワード抽出)
  - 評価機能

Azure において図示すると以下のようなイメージになります。

![](https://storage.googleapis.com/zenn-user-upload/d8ce77271560-20250525.png)

データ準備・ナレッジ活用・評価のサイクルをぐるぐる回すことで、RAG の精度を向上させていきます。

# RAG 精度改善の進め方

```mermaid
flowchart LR
    %% フロー本体 --------------------------------------------------
    A([回答案件用データ<br><sub>(Word / Excel / PPT など)</sub>])
    B([① テキスト])
    C([② チャンク])
    D([③ 検索エンジン])
    E([④ Retrieved データ])
    G([プロンプト<br><sub>(質問含む)</sub>])
    H([⑤ OpenAI Service])
    I([⑥ 回答])

    %% 矢印
    A --> B --> C --> D --> E
    E --> H
    G --> H
    H --> I

    %% ステージ別カラー定義 --------------------------------------
    classDef store    fill:#d95829,color:#ffffff,stroke:#d95829;
    classDef retrieve fill:#2b8d3d,color:#ffffff,stroke:#2b8d3d;
    classDef augment  fill:#1b2b4f,color:#ffffff,stroke:#1b2b4f;
    classDef generate fill:#1c6ed2,color:#ffffff,stroke:#1c6ed2;

    %% ノードにカラー付与
    class A,B,C                        store;
    class D,E                          retrieve;
    class G                            augment;
    class H,I                          generate;

```

## Store の精度向上 (データ準備)

## Retrieve の精度向上 (検索)

## Augment の精度向上 (拡張)

## Generation の精度向上 (生成)

# Evaluate (評価)

# RAG とファインチューニング

# RAG と CAG

# その他

# 参考文献

https://github.com/microsoft/RAG-Knowledge
https://ai.meta.com/blog/retrieval-augmented-generation-streamlining-the-creation-of-intelligent-natural-language-processing-models/
https://www.promptingguide.ai/jp/techniques/rag
https://ja.wikipedia.org/wiki/%E3%83%8F%E3%83%AB%E3%82%B7%E3%83%8D%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3_(%E4%BA%BA%E5%B7%A5%E7%9F%A5%E8%83%BD)
https://arxiv.org/abs/2501.09136
https://github.com/microsoft/ai-agents-for-beginners/tree/main
https://speakerdeck.com/hirosatogamo/chatgpt-azure-openai-da-quan
